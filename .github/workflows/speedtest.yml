# Имя рабочего процесса, которое будет отображаться в GitHub Actions
name: Network Throughput Test

# Триггеры для запуска:
# - push: при любом пуше в ветку main
# - workflow_dispatch: позволяет запускать вручную со страницы Actions в GitHub
on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  # Название задачи
  build-and-run-test:
    # Запускать на последней доступной виртуальной машине с Ubuntu
    runs-on: ubuntu-latest

    steps:
      # Шаг 1: Установка зависимостей (gcc и другие утилиты для сборки)
      - name: Install build dependencies
        run: sudo apt-get update && sudo apt-get install -y build-essential

      # Шаг 2: Создание файла с исходным кодом C
      # Используется here-document (cat <<'EOF' ... EOF), чтобы легко вставить
      # многострочный код в файл. Кавычки вокруг 'EOF' предотвращают
      # интерпретацию специальных символов оболочкой.
      - name: Create C source file
        run: |
          cat <<'EOF' > network_test.c
          #define _GNU_SOURCE
          #include <stdio.h>
          #include <stdlib.h>
          #include <string.h>
          #include <pthread.h>
          #include <unistd.h>
          #include <sys/socket.h>
          #include <netinet/in.h>
          #include <netdb.h>
          #include <time.h>
          #include <errno.h>

          #define HOST "speed.cloudflare.com"
          #define PORT 80
          #define PATH_TEMPLATE "/__down?bytes=%llu"
          #define TOTAL_BYTES (2ULL * 1024 * 1024 * 1024) // 2 GB
          #define NUM_THREADS 4
          #define BUFFER_SIZE (1024 * 1024) // 1 MB

          // Структура для передачи данных в поток
          typedef struct {
              int thread_id;
              unsigned long long bytes_to_download;
              long long downloaded_bytes;
              char path[256]; // <-- ИСПРАВЛЕНО: добавлено это поле
          } thread_data_t;

          // Функция для обработки ошибок
          void error(const char *msg) {
              perror(msg);
              exit(EXIT_FAILURE);
          }

          // Основная функция потока для загрузки данных
          void *download_worker(void *arg) {
              thread_data_t *data = (thread_data_t *)arg;
              int sockfd, bytes_received;
              struct sockaddr_in serv_addr;
              struct hostent *server;
              char *buffer = malloc(BUFFER_SIZE);
              if (!buffer) {
                  error("ERROR allocating buffer");
              }
              
              // Привязка потока к ядру (может не сработать в контейнеризированной среде GH Actions, но не критично)
              cpu_set_t cpuset;
              CPU_ZERO(&cpuset);
              CPU_SET(data->thread_id % sysconf(_SC_NPROCESSORS_ONLN), &cpuset);
              if (pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset) != 0) {
                  fprintf(stderr, "Warning: Could not set thread affinity: %s\n", strerror(errno));
              }

              // Создание сокета
              sockfd = socket(AF_INET, SOCK_STREAM, 0);
              if (sockfd < 0) {
                  error("ERROR opening socket");
              }

              server = gethostbyname(HOST);
              if (server == NULL) {
                  fprintf(stderr, "ERROR, no such host\n");
                  close(sockfd);
                  free(buffer);
                  pthread_exit(NULL);
              }

              // Настройка адреса сервера
              memset(&serv_addr, 0, sizeof(serv_addr));
              serv_addr.sin_family = AF_INET;
              serv_addr.sin_port = htons(PORT);
              memcpy(&serv_addr.sin_addr.s_addr, server->h_addr, server->h_length);

              // Подключение к серверу
              if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
                  error("ERROR connecting");
              }

              // Формирование и отправка HTTP GET запроса
              char request[512];
              sprintf(request, "GET %s HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n", data->path, HOST);
              if (send(sockfd, request, strlen(request), 0) < 0) {
                  error("ERROR writing to socket");
              }

              // Пропуск HTTP заголовков
              char *header_end = NULL;
              int total_header_len = 0;
              while ((bytes_received = recv(sockfd, buffer + total_header_len, BUFFER_SIZE - total_header_len - 1, 0)) > 0) {
                  total_header_len += bytes_received;
                  buffer[total_header_len] = '\0';
                  header_end = strstr(buffer, "\r\n\r\n");
                  if (header_end) {
                      header_end += 4; // Перемещаем указатель на начало тела ответа
                      break;
                  }
              }

              if(bytes_received <= 0 && !header_end) {
                  error("ERROR finding HTTP header end");
              }

              long long body_bytes_in_first_recv = total_header_len - (header_end - buffer);
              data->downloaded_bytes = body_bytes_in_first_recv;
              
              // Чтение тела ответа (данных файла)
              while (data->downloaded_bytes < data->bytes_to_download && (bytes_received = recv(sockfd, buffer, BUFFER_SIZE, 0)) > 0) {
                  data->downloaded_bytes += bytes_received;
              }

              if (bytes_received < 0) {
                  perror("ERROR reading from socket");
              }

              close(sockfd);
              free(buffer);
              pthread_exit(NULL);
          }

          int main() {
              pthread_t threads[NUM_THREADS];
              thread_data_t thread_data[NUM_THREADS];
              struct timespec start, end;
              long long total_downloaded = 0;

              printf("Starting network throughput test...\n");
              printf("Total size to download: %llu bytes (%.2f GB)\n", TOTAL_BYTES, TOTAL_BYTES / (1024.0 * 1024.0 * 1024.0));
              printf("Number of threads: %d\n\n", NUM_THREADS);
              
              unsigned long long bytes_per_thread = TOTAL_BYTES / NUM_THREADS;

              clock_gettime(CLOCK_MONOTONIC, &start);

              // Создание потоков
              for (int i = 0; i < NUM_THREADS; i++) {
                  thread_data[i].thread_id = i;
                  thread_data[i].bytes_to_download = bytes_per_thread;
                  thread_data[i].downloaded_bytes = 0;
                  snprintf(thread_data[i].path, sizeof(thread_data[i].path), PATH_TEMPLATE, bytes_per_thread);

                  if (pthread_create(&threads[i], NULL, download_worker, &thread_data[i]) != 0) {
                      error("ERROR creating thread");
                  }
              }

              // Ожидание завершения всех потоков
              for (int i = 0; i < NUM_THREADS; i++) {
                  pthread_join(threads[i], NULL);
                  total_downloaded += thread_data[i].downloaded_bytes;
              }

              clock_gettime(CLOCK_MONOTONIC, &end);

              // Расчет и вывод результатов
              double duration = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
              if (duration == 0) duration = 1e-9; // Избегаем деления на ноль
              double throughput_gbps = (total_downloaded * 8) / (duration * 1e9);
              double throughput_mbps = throughput_gbps * 1000;

              printf("\nTest finished.\n");
              printf("Total bytes downloaded: %lld\n", total_downloaded);
              printf("Time elapsed: %.4f seconds\n", duration);
              printf("Throughput: %.2f Mbps (%.2f Gbps)\n", throughput_mbps, throughput_gbps);

              return 0;
          }
          EOF

      # Шаг 3: Компиляция кода с помощью gcc
      - name: Compile C code
        run: gcc -O3 -Wall -o network_test network_test.c -pthread

      # Шаг 4: Запуск исполняемого файла с правами sudo
      - name: Run network test
        run: sudo ./network_test
